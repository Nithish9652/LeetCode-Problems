class Solution {
public:
    vector<int>rank;
    vector<int>parent;
    map<int,int>rec;
    vector<vector<int>> graph;


    void solve(int v){
        queue<int>q;
        q.push(v);
        parent[v] = v;

        while(!q.empty()){
            int t = q.front();
            q.pop();
            for(int i =0; i<graph[t].size(); i++){
                if( parent[i] != v && graph[t][i] ==1){ // to avoid re pushing to queue.
                    parent[i] = v;
                    q.push(i);
                }
            }
        }

    }


    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        // I will be using different notations : 
        // I will be doing the dfs 
        // then i will be maintaining the map theat will tell me the count
        // in case the iniital is alredy visited then i will mark the parent that will be there
        // as zero. and rest i will expalin while coding.
        this->graph = graph; 
        int n = graph.size();

        rank.resize(n,1);
        parent.resize(n);

        for(int i =0; i<n; i++){
            parent[i] = i;
        }

        for(auto itr : initial){
            if(parent[itr] != itr) {rec[parent[itr]] =0; rec[itr] =0;} // means no use of removing that parent one.
            else{
                rec[itr] = -1; // will fix is later if count is not 0;
                solve(itr);

            }
        }

        int maxi =-1;
        int index = n+1; 
        for(auto & itr : rec){
            if(itr.second == -1){
                int count =0;
                for(int i =0; i<n; i++){
                    if(parent[i] == itr.first){
                        count++;
                    }
                }

                if(maxi <= count){
                    if(maxi < count){
                        maxi = max(maxi,count);
                        index = itr.first;
                    }
                    else {
                        index = min(index,itr.first); // smallest index.
                    }
                }

            }

            else{ // incase of the zero hai. 
                if(maxi <= 0){
                    if(maxi < 0){
                        maxi = max(maxi,0);
                        index = itr.first;
                    }
                    else {
                        index = min(index,itr.first);
                    }
                }
            }
        }
        return index;
    }
};